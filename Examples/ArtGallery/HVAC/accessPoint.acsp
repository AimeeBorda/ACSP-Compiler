

EventsA = {|connect,disconnect,update|}
MonitorsA = {}

channel adapt3 : Connections


---------------------------------------------
--		Processes for Access Point
---------------------------------------------

A0 = connect!True!HVAC -> RUN({connect.x.y | x<- Bool, y <- {Secure,Open}})
A1 = connect!False!HVAC -> RUN({connect.x.y | x<- Bool, y <- {Secure,Open}})
A2 = disconnect -> connect!True!HVAC -> RUN({connect.x.Secure | x<- Bool})
A3 = RUN({connect.x.y | x<- Bool, y <- {Secure,Open}})
A4 = disconnect -> connect!True!HVAC -> RUN({connect.x.y | x<- Bool, y <- {Secure,Open}})


---------------------------------------------
--		Internal State for Access Point
---------------------------------------------
SAV(v) =  (v < MaxConnections & connect!True!Open -> SAV(v + 1))
		[] (v > 0 & connect!False!Open -> SAV(v - 1))
		[] (disconnect -> SAV(0))

SAS(s) =  (s < MaxConnections & connect!True!Secure -> SAS(s + 1))
		[] (s > 0 & connect!False!Secure -> SAS(s - 1))

SAH(h) =  (connect!True!HVAC -> SAH(True))
		[] (connect!False!HVAC -> SAH(False))

SAU = update -> SAU

Behaviour = SAV(0) ||| SAS(0)  ||| SAH(False) ||| SAU
---------------------------------------------
--		Pattern for Access Point
---------------------------------------------
Pattern3A =   let P(n) =
				   (connect!True!Secure -> if n == 0 then adapt3!1 -> ack -> P(1) else if n < MaxConnections then P(n+1) else P(MaxConnections))
					[] (connect!False!Secure -> if n == 1 then adapt3!0 -> ack -> P(0) else if n > 0 then P(n-1) else P(0))
					[] (disconnect -> P(n))
					[] (update -> P(n))
					[] (connect?_:Bool?_:{HVAC,Open} -> P(n))
				within P(0)

Pattern3B =   let P(n) = (connect!True!Open -> if n == 0 then adapt3!n+1 -> ack -> P(1) else if n < MaxConnections then P(n+1) else P(MaxConnections))
						[] (connect!False!Open -> if (n == 1) then adapt3!0 -> ack -> P(0) else if n > 0 then P(n-1) else P(0))
						[] (disconnect -> P(0))
						[] (update -> P(n))
						[] (connect?_:Bool?_:{HVAC,Secure} -> P(n))
				within P(0)

Pattern6 =      (connect?_ -> Pattern6)  [] (disconnect -> Pattern6) [] (update -> adapt6 -> ack -> Pattern6)


---------------------------------------------
--		Adaptation Function
---------------------------------------------
Pi3A =  adapt3?n : Connections ->
						if n == 1 then l!<A2>. ack -> Pi3A
						else if n == 0 then l!<A3>. ack -> Pi3A
						else ack -> Pi3A

Pi3B =  adapt3?n : Connections ->
						if n == 1 then l!<A1>. ack -> Pi3B
						else if n == 0 then l!<A0>. ack -> Pi3B
						else ack -> Pi3B

Pi6 =  adapt6 -> l!<A4>. ack -> Pi6

---------------------------------------------
--		Composition
---------------------------------------------
accessPtComp = let
			R3A = (Pi3A [|{| adapt3,ack |}|] Pattern3A) \ {| adapt3,ack|}
			R3B = (Pi3B [|{| adapt3,ack |}|] Pattern3B) \ {| adapt3,ack|}
			R6 = (Pi6 [|{| adapt6,ack |}|] Pattern6) \ {|adapt6,ack|}
			AdaptationProc = ((R3A [| EventsA |] R6) [|EventsA|] R3B) [| {|connect,disconnect|}|] Behaviour
        within
			(new l)(l[A0] [| EventsA |] AdaptationProc)