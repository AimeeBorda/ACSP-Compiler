---------------------------------------------
--		Event for Corridor Two
---------------------------------------------

EventsC2 = {goto.Str.Corr2,goto.Corr2.Str, grd.Corr2.Str, grd.Str.Corr2,goto.Corr2.RA,goto.RA.Corr2,grd.Corr2.RA,grd.RA.Corr2}
Monitors1C2 =  {emergency}
MonitorsC2 = union(Monitors5, Monitors1C2)

---------------------------------------------
--		Processes for Corridor Two
---------------------------------------------

C2_0 =  (goto?_: {x | goto.x <- EventsRA} -> C2_0)
		[] (grd?_: {x | grd.x <- EventsRA} -> C2_0)


C2_1 = 	(goto?_: {x | goto.x <- EventsRA} -> C2_1)
		[] grd?_:{Str,RA}!Corr2 -> C2_1
		[] grd!Corr2!RA -> C2_1

---------------------------------------------
--		State for Corridor Two
---------------------------------------------

C(n) = (n > 0 & goto!Corr2?_:{RA,Str} -> C(n-1))
		[] (n < MaxAgents & goto?_:{RA,Str}!Corr2 -> C(n+1))

C2(b) = (b & grd!Corr2?_:{RA,Str} -> C2(False))
		[] (not b & grd?_:{RA,Str}!Corr2 -> C2(False))

Beh = C(0) ||| C2(False)

---------------------------------------------
--		Pattern for Corridor Two
---------------------------------------------

Pattern1C2 = let P(n) = (goto!Corr2!Str -> if n == 1 then adapt!n-1 -> ack -> P(n-1) else if n > 0 then P(n-1) else P(0))
						[] (goto!Str!Corr2 -> if n == 0 then adapt!n+1 -> ack -> P(n+1) else if n < MaxAgents then P(n+1) else P(MaxAgents))
						[] (goto?_ :{x.y| x <- {RA,Corr2}, y <- {RA,Corr2},x!=y} -> P(n))
						[] (grd?_ :{x | grd.x <- EventsC2} -> P(n))
						[] (emergency -> RUN(union(EventsC2,Monitors1C2)))
			within P(0)
Pi1C2 = adapt?n -> if n > 0 then c2!<C2_0>.ack ->  Pi1C2 else c2!<C2_1>.ack -> Pi1C2


Pattern5C2 = (emergency -> adaptE -> ack -> Pattern5C2) [] (goto?_: {x | goto.x <- EventsC2} -> Pattern5C2) [] (grd?_: {x | grd.x <- EventsC2} -> Pattern5C2)
Pi5C2 =  adaptE  ->  c2!<C2_0>.ack -> Pi5C2


---------------------------------------------
--		Composition for Corridor Two
---------------------------------------------

CorrTwo = let
		eventsR1 = union(EventsC2,Monitors1C2)
		eventsR5 = union(EventsC2,Monitors5)

		events = union(eventsR1,eventsR5)
		R1 = (Pattern1C2 [|{|adapt,ack|}|] Pi1C2) \ {|adapt,ack|}
		R5 = (Pattern5C2 [|{|adaptE,ack|}|] Pi5C2) \ {|adaptE,ack|}


		AdaptationProc = Beh [|inter(EventsC2,events)|] (R1  [|inter(eventsR1,eventsR5)|] R5)

    within
		(new c2)(c2[C2_0] [| EventsC2 |] AdaptationProc)