channel adapt2 : Bool.Bool
---------------------------------------------
--		Event Status
---------------------------------------------

EventStatus = event!Before -> event!During -> event!After -> EventStatus

---------------------------------------------
--		Light
---------------------------------------------
Lights_0 = lights!True -> STOP
Lights_1 = lights!False -> STOP
PI =
		let B(n,emp,ev) = (goto!Emp?_:sections -> B(n,emp,ev))

				[] (event!During-> adapt2!n!emp -> ack ->  B(n,emp,During))
				[] (event!Before -> adapt2!n!False -> ack -> B(n, True,Before))
				[] (event!After ->  B(n,emp,After))
				[] (empty -> if ev == After then adapt2!n!True -> ack -> B(n,True,ev) else B(n,emp,ev))

				[] (goto?_ :notE?_:adj!s -> if emp and ev != Before then adapt2!n!False -> ack -> B(n,False,ev) else B(n,False,ev))
				[] (goto?_ :notE!s?_:adj -> B(n,emp,ev))

				[] (open?_ : {x.y | x.y <- openEvt, y !=s} -> B(n,emp,ev))
				[] (open?_ : {x.y | x.y <- openEvt, y ==s} -> adapt2!n!False -> ack -> B(n,False,ev))
				[] (lights?b -> B(b,emp,ev))
			within B(False,True,Before)


FI = adapt2?l?emp -> if l and emp then c!<Lights_1>. ack -> FI else if not l and not emp then c!<Lights_0>.ack -> FI else c!<STOP>.ack -> FI


LightsPanel = let
		AdaptationProc = (PI [| {|adapt2,ack|} |] FI) \ {|adapt2,ack|}
	within
		(new l)(l[STOP] [| {|lights|} |] AdaptationProc)

---------------------------------------------
--		Noise Panel
---------------------------------------------

Noisy_0 = noisy!False -> STOP
Noisy_1(b) = noisy!b -> Noisy_1(not b)

PH =
		let B(n,emp,ev) = (goto!Emp?_:sections -> B(n,emp,ev))
				[] (event!Before -> adapt2!n!True -> ack -> B(n,True,Before))
				[] (event!During -> if emp then adapt2!n!emp -> ack-> B(n,emp,During) else B(n,emp,During))
				[] (event!After -> adapt2!n!True-> ack -> B(n,emp,After))
				[] (noisy?b -> B(b,emp,ev))
				[] (empty -> if ev == During then adapt2!n!True -> ack ->  B(n,True,ev) else B(n,True, ev))
				[] (goto?_ :notE?_:adj!s -> if ev == During and emp then  adapt2!n!False -> ack->  B(n,False,ev)else B(n,False,ev))
				[] (goto?_ :notE!s?_:adj -> B(n,emp,ev))
				[] (open?_ :openEvt-> B(n,emp,ev))
			within  B(False,True,Before)

FH = adapt2?n?emp -> if emp and n then nl!<Noisy_0>.ack -> FH
					else if not emp and n then nl!<Noisy_1(False)>.ack -> FH
					else if not emp and not n then nl!<Noisy_1(True)>. ack -> FH
					else if emp and not n then nl!<STOP>.ack -> FH
					else ack -> FH

NoisePanel = let
		AdaptationProc = (PH [| {|adapt2,ack|} |] FH) \ {|adapt2,ack|}
	within
		(new nl)(nl[STOP] [| {|noisy|} |] AdaptationProc)


---------------------------------------------
--		Alarm Component
---------------------------------------------

Alarm_1(b) = alarm!b -> Alarm_1(not b)

AlarmPanel = Alarm_1(True)