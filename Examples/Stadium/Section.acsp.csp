 ---------------------------------------------
--		Adaptation Events
---------------------------------------------

channel adapt
channel adapt1 : Bool

channel ack

---------------------------------------------
--		Helper Functions
---------------------------------------------

next(L.x) = if x < NumSections then L.x + 1 else L.0
next(H.x) = if x < NumSections then H.x + 1 else H.0
next(VIP.x) = if x < NumSections then VIP.x + 1 else VIP.0
next(_) = Corr


prev(L.x) = if x > 0 then L.x - 1 else L.NumSections
prev(H.x) = if x > 0 then H.x - 1 else H.NumSections
prev(VIP.x) = if x > 0 then VIP.x - 1 else VIP.NumSections
prev(_) = Corr


adj(s) = {next(s),prev(s),Corr}
sections(s) = {y.z | y <- union({s},adj(s)), z <- union({s},adj(s)), y!=z,z == s or y ==s } 

openEvt = \ s @ {x.y | x <- SectionID, y <- SectionID, x == s or y ==s, x!=Corr, y != Corr}
gotoEvt = \ s @{goto.x.y.s,goto.x.s.y | x <- Agent, y <- adj(s)}

monEvents = \ s @ {| noisy.s,event,wind ,alarm.s |} 
locEvents = \s @ Union({gotoEvt(s),{open.x | x <- openEvt(s)}	})
events = \s @ Union({locEvents(s), monEvents(s), {|empty|}})
adEvents = {|ack,adapt,adapt1|}

---------------------------------------------
--		Processes for A Section
---------------------------------------------

Behaviour(s,n) = (n > 0 & goto?_:{x | x<- Agent, x!= Emp}!s?_: adj(s) -> Behaviour(s,n-1))
				[] (n < SectionSize & goto?_:{x | x<- Agent, x!= Emp}?_:adj(s)!s -> Behaviour(s,n+1))
				[] (goto!Emp?_:sections(s) -> Behaviour(s,n))
				[] (n == 0 & empty -> Behaviour(s,n))
				

SOpen(s) = goto?_:{s,Emp}?_:adj(s)!s -> SOpen(s) [] goto?_:{s,Emp}!s?_ :adj(s) -> SOpen(s)
SExitAdj(s) = goto!Emp?_:sections(s) ->  SExit(s) [] goto?_!s!Corr -> SExit(s) [] goto?_?_:{next(s), prev(s)}!s -> SExit(s) 
SRoaming(s) = goto?_?_:adj(s)!s -> SRoaming(s)	[] goto?_!s?_: adj(s) -> SRoaming(s)
SExit(s) = goto!Emp?_:sections(s) ->  SExit(s) [] goto?_!s!Corr -> SExit(s) 

EventStatus = event!Before -> event!During -> event!After -> EventStatus
---------------------------------------------
--		Pattern for Req. A : event Pi (Before: ticketType)
---------------------------------------------

PA(s) = let B = (event!Before  -> adapt -> ack -> B) 
				[] (goto?_?_: sections(s) -> B) 
				[] (event?_:{During,After} -> B) 
				[] (open?_ : openEvt(s) -> B) 
				[] (alarm!s -> B) 
				[] (empty -> B) 
				[] (wind -> B) 
				[] (noisy!s -> B)
		within B

FA = adapt -> ac!0 -> ack -> FA


---------------------------------------------
--		Pattern for Req. B : event Pi After
---------------------------------------------

PB(s) = let B(aft,others) = (event!After  -> adapt1!False -> ack -> B(True,others)) 
				[] (goto?_?_: sections(s) -> B(aft,others)) 
				[] (event!Before -> B(False,False))
				[] (event!During -> B(False,others)) 
				[] (open?_ : openEvt(s) -> B(aft,others))
				[] (alarm!s -> B(aft,True)) 
				[] (empty -> if not others and aft then adapt1!True -> ack -> B(aft,others) else B(aft,others)) 
				[] (wind -> B(aft,others or member(s,{|H|}))) 
				[] (noisy!s -> B(aft,others))
	within B(False,False)

FB = adapt1?emp -> if not emp then  ac!1 -> ack -> FB  else if  emp then ac!2 -> ack->FB else ack->FB

---------------------------------------------
--		Pattern for Req. C : alarm => exit
---------------------------------------------

PC(s) = let B = (alarm!s  -> adapt-> ack -> B) 
				[] (goto?_?_: sections(s) -> B) 
				[] (noisy!s -> B)
				[] (event?_ -> B) 
				[] (open?_ : openEvt(s) -> B) 
				[] (empty -> B) 
				[] (wind -> B) 
	within B

FC = adapt -> ac!1-> ack -> FC

---------------------------------------------
--		Pattern for Req. D : during roam unless empty, alarm, wind, noisy
---------------------------------------------

PD(s) = let 
			B(others,emp,dur) =  
							(goto?_:notE?_:adj(s)!s -> if dur and not others then adapt1!False -> ack -> B(others,False,dur) else B(others,False,dur)) 
						[] (goto!Emp?_ : sections(s) -> B(others,emp,dur)) 
						[] (goto?_:notE!s?_:adj(s) -> B(others,emp,dur)) 
						[] (empty -> B(others,emp,dur))
						[] (open?_ :openEvt(s) -> B(others,emp,dur)) 

						[] (event!Before -> B(False,True,False)) 
						[] (event!After -> B(others,emp,False)) 
						[] (event!During -> if not others then  adapt1!emp -> ack -> B(others,emp,True) else B(others,emp,True)) 						
						
						[] (wind -> B(others or member(s, {|H|}),emp,dur)) 
						[] (alarm!s -> B(True,emp,dur)) 
						[] (noisy!s -> B(True,emp,dur)) 
		
		within B(False,True,False)
 
FD = adapt1?emp:Bool -> if not emp then ac!6 -> ack -> FD else if emp then ac!3 -> ack -> FD else ack -> FD

---------------------------------------------
--		Pattern for Req. E : windy => (close H and open backup) or (ticketType)
---------------------------------------------

PE(s) = let 
			A(alrm,w,dur) = 
					(goto?_?_: sections(s) -> A(alrm,w,dur)) 
				[] (open!s?_ :{y | x.y <- openEvt(s),x==s} -> if not alrm and dur and w then adapt1!True -> ack -> A(alrm,w,dur)else A(alrm,w,dur)) 
				[] (open?_ : {x.y | x.y <- openEvt(s), x != s} -> A(alrm,w,dur)) 
				[] (empty -> A(alrm,w,dur))	

				[] (event!Before -> A(False,False,False)) 
				[] (event!During -> if not alrm and w then adapt1!False -> ack -> A(alrm,w,True) else A(alrm,w,True)) 
				[] (event!After -> A(alrm,w,False)) 

				[] (wind -> if not alrm and dur and member(s, {|H|}) then adapt1!False -> ack -> A(alrm,member(s, {|H|}),dur) else A(alrm,member(s, {|H|}),dur))	
				[] (alarm!s -> A(True,w,dur)) 
				[] (noisy!s -> A(alrm,w,dur))
		within A(False,False,False)
 
FE = adapt1?backup -> if not backup then ac!4 -> ack -> FE else if backup then ac!1 -> ack -> FE else ack->FE

---------------------------------------------
--		Pattern for Req. F : if noisy by ticket type and open backup
---------------------------------------------

PF(s) = let
			B(ev,o) = (goto?_ ?_: sections(s)-> B(ev,o)) 
					[] (event!Before -> B(False,False)) 
					[] (event!After -> B(False,o)) 
					[] (event!During -> B(True,o)) 
					[] (open?_ : openEvt(s) -> B(ev,o)) 
					[] (noisy!s -> if not o  and ev then adapt -> ack -> B(ev,o) else B(ev,o) ) 
					[] (wind -> B(ev,o or member(s,{|H|}))) 
					[] (alarm!s -> B(ev,True))
					[] (empty -> B(ev,o))
	
		within B(False,False) 

FF = adapt -> ac!5 -> ack -> FF

---------------------------------------------
--		Pattern for Req. G : empty can be used as a backup (empty event, no backup if wind,alarm)
---------------------------------------------

PG(s) = let B(o,e,d) = (goto!Emp?_: adj(s)!s -> B(o,e,d)) 
				[] (goto?_:notE?_: adj(s)!s -> B(o,False,d)) 
				[] (goto?_!s?_: adj(s) -> B(o,e,d)) 
				[] (event!Before -> B(False,True,False))  
				[] (event!After -> B(o,e,False))  
				[] (open?_ : {x.y | x.y <- openEvt(s), y != s} -> B(o,e,d)) 
				[] (open?_ : {x.y | x.y <- openEvt(s), y == s} -> if not o and e then adapt1!d -> ack -> B(o,e,d) else B(o,e,d)) 
				[] (wind -> B(o or member(s, {|H|}),e,d))
				[] (noisy!s ->B(True,e,d)) 
				[] (event!During -> B(o,e,True)) 
				[] (empty -> B(o,e,d)) 
				[] (alarm!s -> B(True,e,d)) 
				
		within B(False,True,False)

FG = adapt1?d -> if d then ac!6 -> ack -> FG else if not d then ac!7 -> ack -> FG else ack -> FG

---------------------------------------------
--	Named Location
---------------------------------------------
Sys(s) = 
		let 
			map = \ id @ (	  if id == 0 then SOpen(s)
						 else if id == 1 then SExit(s) ||| open!s?_ : {x | x <- adj(s), x!= Corr} -> SKIP
						 else if id == 2 then SExit(s) ||| open?_ : {x | x <- adj(s), x!= Corr}!s -> SKIP
						 else if id == 4 then SOpen(s) 	 ||| (open!s?_ : {L.x, VIP.x | x <- {0..NumSections}} -> SKIP)
						 else if id == 5 then SOpen(s)   ||| (open!s?_ : {x | x <- SectionID, x!=s,x!=Corr}-> SKIP)
						 else if id == 7 then SExitAdj(s) --||| (open?_ : {x | x <-adj(s), x!=Corr}!s -> SKIP)
						 else if id == 6 then SRoaming(s)
						 else if id == 3 then SOpen(s) ||| (open?_ : {x | x <-SectionID, x!=s, x!=Corr}!s -> SKIP)
						 else SKIP)
			SysDRec = (ac?id  -> (map(id) /\ SysDRec))
		within
			SExit(s) /\ SysDRec

---------------------------------------------
--		Composition
---------------------------------------------

AccessController(s) = let
		
		
		RA = (PA(s) [| adEvents |] FA) \ adEvents
		RB = (PB(s) [| adEvents |] FB) \ adEvents
		RC = (PC(s) [| adEvents |] FC) \ adEvents
		RD = (PD(s) [| adEvents |] FD) \ adEvents
		RE = (PE(s) [| adEvents |] FE) \ adEvents
		RF = (PF(s) [| adEvents |] FF) \ adEvents
		RG = (PG(s) [| adEvents |] FG) \ adEvents

		C1 = (RA [| events(s) |] RB)
		C2 = (C1 [| events(s) |] RC)
		C3 = (C2 [| events(s) |] RD)
		C4 = (C3 [| events(s) |] RE)
		C5 = (C4 [| events(s) |] RF)
		C6 = (C5 [| events(s) |] RG)


		AdaptationProc = (C6 [|{|goto,empty|}|] Behaviour(s,0))
		
	within
			normal(Sys(s) [| union(locEvents(s),{|ac|}) |] AdaptationProc \ {| ac |})

Section(s) = AccessController(s) [|{|event|}|] EventStatus