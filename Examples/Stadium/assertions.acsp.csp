notE = {x | x <- Agent, x != Emp}
---------------------------------------------
--		Req. 1: enter on ticket type
---------------------------------------------

ReqA(s) = 	let 
				R =  (goto?_?_:sections(s) -> R) 
					[] (noisy!s -> R) 
					[] (wind -> R) 
					[] (alarm!s -> R) 
					[] (event!Before -> B) 
					[] (event?_:{During,After} -> R) 
					[] (open?_ : openEvt(s) -> R) 
					[] (empty -> R)
				B = (goto!Emp?_:adj(s)!s -> B) 
					[] (goto!s?_:adj(s)!s -> B) 
					[] (event?_:{During,After} -> R) 
					[] (event!Before -> B) 
					[] (empty -> B)
					[] (noisy!s -> B) 
					[] (wind -> B) 
					[] (alarm!s -> R) 
					[] (goto?_!s?_: adj(s) -> B) 
			within R

---------------------------------------------
--		Req. 0: after => exit only 
--		TODO: how do I check open as well on exit
---------------------------------------------

ReqB(s) = 	let 
				
				B(emer) =  
						 (event!During -> B(emer))  
						[] (event!Before -> B(False)) 
						[] (event!After -> T(emer,False)) 
						[] (noisy!s -> B(emer)) 
						[] (wind -> B(emer or member(s,{|H|}))) 
						[] (alarm!s -> B(True)) 
						[] (goto?_?_ :sections(s)-> B(emer)) 
						[] (open?_ : openEvt(s) -> B(emer)) 
						[] (empty -> B(emer))
				T(emer,emp)  = (goto!Emp?_ :sections(s)-> T(emer,emp)) 
						[] (event!During -> B(emer)) 
						[] (event!Before -> B(False)) 
						[] (event!After -> T(emer,False)) 
						[] (noisy!s -> T(emer,emp)) 
						[] (wind -> T(emer or member(s,{|H|}),emp)) 
						[] (alarm!s -> B(True)) 
						[] (goto?_:notE!s!Corr -> T(emer,emp)) 
						[] (empty -> T(emer,True)) 
						[] (emp & goto?_:notE?_:{next(s),prev(s)}!s -> T(emer,emp))
					 	[] (emp & open?_ :{x.y | x.y <- openEvt(s),y==s, member(x, adj(s))} -> T(emer,emp))
					 	[] (not emp or emer & open?_ :{x.y | x.y <- openEvt(s),x==s} -> T(emer,emp))
			within 
				B(False)

---------------------------------------------
--		Req. 3:  alarm => exit
---------------------------------------------

ReqC(s) = 	let 
				R =  (goto?_ ?_:sections(s)-> R) 
					[] (noisy!s -> R) 
					[] (wind -> R) 
					[] (alarm!s -> B) 
					[] (event!After -> R) 
					[] (event?_:{During,Before} -> R) 
					[] (open?_ : openEvt(s) -> R) 
					[] (empty -> R)
				B = (goto!Emp?_:adj(s)!s -> B) 
					[] (event!Before -> R) 
					[] (event?_:{After,During} -> B) 
					[] (noisy!s -> B) 
					[] (wind -> B) 
					[] (open?_ : {x.y | x.y <- openEvt(s), y != s}  -> B) 
					[] (alarm!s -> B) 
					[] (goto?_!s?_: adj(s) -> B) 
					[] (empty -> B)
			within 
				R

---------------------------------------------
--		Req. 2: during visitors can roam unless empty
---------------------------------------------

ReqD(s) = 	let R(emp) = (event!Before -> R(True)) [] (event!During -> during(emp)) [] (event!After -> R(emp)) 
							[] (goto?_: notE?_ :adj(s)!s -> R(False)) [] (goto!Emp?_:adj(s)!s -> R(emp)) [] (goto?_!s?_ :adj(s)-> R(emp))
							[] (noisy!s -> R(emp)) [] (wind -> R(emp)) [] (alarm!s -> R(emp)) [] (open?_ :openEvt(s)-> R(emp)) [] (empty -> R(emp)) 
				during(b) =  (goto!Emp?_ :sections(s)-> during(b)) 
							[] (goto?_:notE!s?_ :adj(s) -> during(b)) 
							[] (b & goto!s?_ :adj(s)!s -> during(False)) 
							[] (not b & goto?_:notE?_ :adj(s)!s -> during(b)) 
							[] (noisy!s -> during(b)) 
							[] (wind -> during(b)) 
							[] (alarm!s -> during(b)) 
							[] (event?_ :{Before,After} -> R(True)) 
							[] (event!During -> during(b)) 
							[] (open?_ : {x.y | x.y <- openEvt(s),y!=s} -> during(b)) 
							[] (b & open?_ : {x.y | x.y <- openEvt(s),y ==s} -> R(b))
							[] (empty -> during(b)) 
			within 
				  R(True)

---------------------------------------------
--		Req. E:  windy => close H (may need to change for during only)
---------------------------------------------

ReqE(s) = let 	
				R1(w) = (goto?_?_:sections(s) -> R1(w)) [] (noisy!s -> R1(w)) [] (wind -> R1(member(s, {|H|}))) 
					[] (open?_ :openEvt(s) -> R1(w)) [] (event!Before  -> R1(False)) [] (event!After  -> R1(w))  
					[] (event!During  -> W(False,w)) [] (alarm!s -> R1(w)) [] (empty -> R1(w)) 
				W(backup,w) = (goto!Emp?_ :sections(s)-> W(backup,w)) 
					[] (not backup and w and member(s,{|H|}) & goto!s?_:adj(s)!s -> W(backup,w)) 
					[] (not w or not member(s,{|H|})& goto?_:notE?_:adj(s)!s -> W(backup,w)) 
					[] (empty -> W(backup,w)) 
					[] (event!After -> R1(w)) 
					[] (event!Before -> R1(False)) 
					[] (event!During -> W(False,w)) 
					[] (noisy!s -> W(backup,w)) 
					[] (wind -> W(False,member(s, {|H|}))) 
					[] (alarm!s -> W(backup,w)) 
					[] (goto?_:notE!s?_: adj(s) -> W(backup,w)) 
					[] (open!s?_ : {x | x <- SectionID, not member(x, {|H|}), x!= s} -> W(w,w))
					[] (open!s?_ : {x | x <- SectionID, member(x, {|H|}), x!= s} -> W(backup,w))	
					[] (not w & open?_ : {x | x <- SectionID, x!= s, x!=Corr}!s -> W(backup,w))	
			within
				R1(False)

---------------------------------------------
--		Req. F:  noisy => open if Closed (need to check that open is performed)
---------------------------------------------

ReqF(s) = let 
			R =  (goto?_?_:sections(s) -> R)
					[] (noisy!s -> R)
					[] (wind -> R)
					[] (alarm!s -> R)
					[] (open?_ :openEvt(s) -> R)  
					[] (empty -> R) 
					[] (event?_ :{Before,After}-> R)
					[] (event!During -> B(False)) 
			B(n) = (goto!Emp?_ :sections(s)-> B(n)) 
					[] (event?_ :{Before,After} -> R)  
					[] (event!During -> B(n))  
					[] (noisy!s -> B(True)) 
					[] (wind -> B(n)) 
					[] (alarm!s -> B(n)) 
					[] (empty -> B(n)) 
					[] (goto?_:notE!s?_: adj(s) -> B(n)) 
					[] (n & open?_ : {x.y | x.y <- openEvt(s),y != s} -> B(n)) 
					[] (not n & open?_ : openEvt(s) -> B(n)) 
					[] (n & goto!s?_:adj(s)!s -> B(n))
					[] (not n & goto?_:notE?_:adj(s)!s -> B(n))
			within R

---------------------------------------------
--		Req. G:  empty can be used as a backup TODO: for when empty
---------------------------------------------

ReqG(s) = 	let 
			R(other,emp,opn) = (goto!Emp?_ :sections(s)-> R(other,emp,opn)) 
				[] (goto?_:notE!s?_:adj(s) -> R(other,emp,opn))  
				[] (emp & goto!s?_:adj(s)!s  -> R(other,False,opn)) 
				[] (not emp or opn &goto?_:notE?_:adj(s)!s  -> R(other,False,opn)) 		
				
				[] (event!During -> R(other,emp,opn))
				[] (event!Before -> B(False,True,False)) 
				[] (event!After -> A(other,emp,opn)) 				
				[] (noisy!s -> R(other,emp,opn)) 
				[] (wind -> R(other or member(s, {|H|}),emp,opn))
				[] (alarm!s -> R(True,emp,opn)) 
				[] (empty -> R(other,emp,opn))
				
				[] (open?_ :{x.y | x.y <- openEvt(s),y != s} -> R(other,emp,opn)) 
				[] (not other and emp & open?_ :{x.y | x.y <- openEvt(s),y == s} -> B(other,emp,True)) 
			B(other,emp,opn) = (goto!Emp?_ :sections(s)-> B(other,emp,opn)) 
				[] (goto?_:notE!s?_:adj(s) -> B(other,emp,opn))  
				[] (goto?_:notE?_ :adj(s) !s -> B(other,False,opn))  

				[] (event!During -> R(other,emp,opn)) 
				[] (event!Before -> B(False,True,False)) 
				[] (event!After -> A(other,emp,opn)) 
				[] (noisy!s -> B(other,emp,opn)) 
				[] (wind -> B(other or member(s, {|H|}),emp,opn))
				[] (alarm!s -> B(True,emp,opn)) 
				[] (empty -> B(other,emp,opn)) 

				[] (open?_ :{x.y | x.y <- openEvt(s),y != s} -> B(other,emp,opn)) 
			A(other,emp,opn) = (goto!Emp?_ :sections(s) -> A(other,emp,opn)) 
				[] (goto?_:notE!s!Corr -> A(other,False,opn))  
				[] (opn & goto?_:notE?_:{next(s),prev(s)}!s -> A(other,emp,opn)) 
				
				[] (event!During -> R(other,emp,opn)) 
				[] (event!Before -> B(False,True,opn)) 
				[] (event!After -> A(other,emp,opn)) 
				[] (noisy!s -> A(other,emp,opn)) 
				[] (wind -> A(other or member(s, {|H|}),emp,opn))
				[] (alarm!s -> A(True,emp,opn)) 
				[] (empty -> A(other,True,opn)) 
				
				[] (open?_ :{x.y | x.y <- openEvt(s),y != s} -> A(other,emp,opn)) 				
				[] (other or emp & open?_ :{x.y | x.y <- openEvt(s),y == s} -> A(other,emp,True)) 
		within 
			B(False,True,False)


---------------------------------------------
--		Verification for Adaptation Patterns
---------------------------------------------

assert PG(L.0) \ adEvents [T= RUN(events(L.0))
assert RUN(events(L.0))[F= PG(L.0) \ adEvents

assert PF(L.0) \ adEvents [T= RUN(events(L.0))
assert RUN(events(L.0))[F= PF(L.0) \ adEvents

assert PE(L.0) \ adEvents [T= RUN(events(L.0))
assert RUN(events(L.0))[F= PE(L.0) \ adEvents

assert PD(L.0) \ adEvents [T= RUN(events(L.0))
assert RUN(events(L.0))[F= PD(L.0) \ adEvents

assert PC(L.0) \ adEvents [T= RUN(events(L.0))
assert RUN(events(L.0))[F= PC(L.0) \ adEvents

assert PB(L.0) \ adEvents [T= RUN(events(L.0))
assert RUN(events(L.0))[F= PB(L.0) \ adEvents

assert PA(L.0) \ adEvents [T= RUN(events(L.0))
assert RUN(events(L.0))[F= PA(L.0) \ adEvents



---------------------------------------------
--		Verification for Requirements
---------------------------------------------

assert ReqA(L.0) [T= Section(L.0) 
assert ReqB(L.0) [T= Section(L.0) 
assert ReqC(L.0) [T= Section(L.0) 
assert ReqD(L.0) [T= Section(L.0) 
assert ReqE(L.0) [T= Section(L.0) 
assert ReqF(L.0) [T= Section(L.0) 
assert ReqG(L.0) [T= Section(L.0) 

---------------------------------------------
--		Basic Assertions
---------------------------------------------

assert Section(L.0) :[deterministic]
assert Section(L.0) :[deadlock free]
assert Section(L.0) :[livelock free]
