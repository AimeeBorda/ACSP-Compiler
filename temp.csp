transparent normal
 -- File /Users/aimee/IdeaProjects/ACSP Compiler/Examples/ArtGallery/ExhibitionArea/RmD.acsp

EventsD = {goto.EB.ED,goto.ED.Corr}
Monitors2 = {|emergency|}
D0 = (goto!ED!Corr -> D0) [] (goto!EB!ED -> D0)
D1 = (goto!ED!Corr -> D1)
BehaviourD = let D(n) =  (n > 0 & goto!ED!Corr -> D(n-1))
					[] (n <= MaxAgentsEA & goto!EB!ED -> D(n+1))
				within D(0)
Pattern2 = let P(n) = 
			(n > 0 & goto!ED!Corr -> if n==MaxAgents then adapt!n-1 -> ack -> P(n-1) else P(n-1))
				[] (n <=MaxAgentsEA & goto!EB!ED -> if n == MaxAgents - 1 then adapt!n+1 -> ack -> P(n+1) else P(n+1))
				[] (emergency -> RUN(union(EventsD,Monitors2)))
		within P(0)
Pi2 =  adapt?v  ->  if v == MaxAgents then rd!0 -> ack -> Pi2 else rd!1 -> ack -> Pi2	


Pattern5D = (emergency -> adaptE -> ack -> RUN(EventsD)) [] (goto?_: {x | goto.x <- EventsD} -> Pattern5D)
Pi5D =  adaptE  -> rd!1 -> ack -> Pi5D
RmD = let
		eventsR2 = union(EventsD,Monitors2)
		eventsR5 = union(EventsD,Monitors5)

		events = union(eventsR2,eventsR5)
		R2 = normal((Pattern2[|{|adapt,ack|}|] Pi2) ) \ {|adapt,ack|}
		R5 = normal((Pattern5D[|{|adaptE,ack|}|] Pi5D) ) \ {|adaptE,ack|}

		FirstApproach = normal((BehaviourD[|inter(EventsD,events)|] normal((R2[|inter(eventsR2,eventsR5)|] R5) )) )
		SecondApproach = normal((BehaviourD[|inter(EventsD,eventsR5)|] R5) )
	within normal((let R = rd?id -> (map(rd,id) /\ R) 
 within (D0/\ R)[|union( EventsD,{| rd|})|] if approachOne then FirstApproach else SecondApproach)  \ {| rd|})

 -- File /Users/aimee/IdeaProjects/ACSP Compiler/Examples/ArtGallery/ExhibitionArea/RmB.acsp

EventsB = {goto.EB.EA,goto.EB.ED,goto.EA.EB}
Monitors2B = {goto.ED.Corr,emergency}
B0 = (goto!EB?_:{EA,ED} -> B0) [] (goto!EA!EB -> B0) 
B1 = (goto!EB?_:{EA,ED} -> B1)
BehaviourB = let B(n) =  (n > 0 & goto!EB?_:{EA,ED} -> B(n-1))
					[] (n <= MaxAgentsEA & goto!EA!EB -> B(n+1))
				within B(0)
Pattern2B = let P(n) = 
		   	   (n >= 0 & goto!EB!EA -> if (n == MaxAgentsPair) then adapt!n-1 -> ack -> P(n-1) else P(n-1)) 
		   	 	[] (n <= MaxAgents & goto!EA!EB -> if (n == MaxAgentsPair-1) then adapt!n+1 -> ack -> P(n+1) else P(n+1))
				[] (n >= 0 & goto!ED!Corr -> if (n == MaxAgentsPair) then adapt!n-1 -> ack -> P(n-1) else P(n-1)) 
				[] (goto!EB!ED -> P(n))
				[] (emergency -> RUN(union(EventsB,Monitors2B)))
			within P(0)
Pi2B =  adapt?v  ->  if v == MaxAgentsPair then rb!0 -> ack -> Pi2B else rb!1 -> ack -> Pi2B


Pattern5B = (emergency -> adaptE -> ack -> RUN(EventsB)) [] (goto?_: {x | goto.x <- EventsB} -> Pattern5B)
PiEmergencyB =  adaptE  -> rb!1 -> ack -> PiEmergencyB
RmB = let
			eventsR2B = union(EventsB,Monitors2B)
			eventsR5 = union(EventsB,Monitors5)

			events = Union({eventsR2B,eventsR5})
			R5 = normal((PiEmergencyB[|{|adaptE,ack|}|] Pattern5B) )  \ {|adaptE,ack|}
			R2B = normal((Pi2B[|{|adapt,ack|}|] Pattern2B) ) \ {|adapt,ack|}
			
			FirstApproach = normal((R5[|inter(EventsB,eventsR5)|] BehaviourB) )
			SecondApproach = normal((BehaviourB[|inter(EventsB,events)|] normal((R5[|inter(eventsR5,eventsR2B)|] R2B) )) ) 
		within normal((let R = rb?id -> (map(rb,id) /\ R) 
 within (B0/\ R)[|union( EventsB,{| rb|})|] (if(approachOne) then FirstApproach else SecondApproach))  \ {| rb|})

 -- File /Users/aimee/IdeaProjects/ACSP Compiler/Examples/ArtGallery/ExhibitionArea/RmA.acsp
EventsA = {goto.EB.EA,goto.EA.Corr,goto.EA.EB,goto.Corr.EA}

Monitors4 = {goto.ED.Corr,emergency}
Monitors2A = {goto.EB.ED,emergency}
Monitors5 = {emergency}
A0 = (goto!EB!EA -> A0) [] (goto!EA?_:{Corr,EB} -> A0) [] (goto!Corr!EA -> A0)
A1 = (goto!EB!EA -> A1) [] (goto!EA?_:{Corr,EB} -> A1)
BehaviourA =  let B(n) = (n <= MaxAgentsEA & goto!Corr!EA -> B(n+1))
							[] (n > 0 & goto!EA!Corr -> B(n-1))
							[] (n > 0 & goto!EA!EB -> B(n-1))
							[] (n <= MaxAgentsEA & goto!EB!EA -> B(n+1))
				within B(0)
Pattern4 =  
		let P(n) =  (n > 0 & goto?_:{EA,ED}!Corr -> if (n == MaxAgentsEA) then adapt!n-1 -> ack-> P(n-1) else P(n-1))
				[] (n <= MaxAgentsEA & goto!Corr!EA -> if (n == MaxAgentsEA - 1) then adapt!n+1 -> ack -> P(n+1) else P(n+1))
				[] (goto!EA!EB -> P(n))  
				[] (goto!EB!EA -> P(n)) 
				[] (emergency -> RUN(union(EventsA,Monitors4))) 
			
		within P(0)
Pi4 =  adapt?v  ->  if v >= MaxAgentsEA then ra!0 -> ack -> Pi4 else ra!1 -> ack -> Pi4

Pattern2A = let P(n) =  (n <= MaxAgentsPair & goto!Corr!EA -> if (n == MaxAgentsPair - 1) then adapt!n+1 -> ack -> P(n+1) else P(n+1))
					[] (n > 0 & goto!EA!Corr -> if (n == MaxAgentsPair) then adapt!n-1 -> ack -> P(n-1) else P(n-1))
					[] (n > 0 & goto!EB!ED   -> if (n == MaxAgentsPair) then adapt!n-1 -> ack -> P(n-1) else P(n-1))
					[] (goto!EA!EB -> P(n))  
					[] (goto!EB!EA -> P(n)) 
					[] (emergency -> RUN(union(EventsA,Monitors2A))) 
			within P(0)
Pi2A =  adapt?v  ->  if v >= MaxAgentsPair then ra!0 -> ack -> Pi2A else ra!1 -> ack -> Pi2A


Pattern5A = (emergency -> adaptE -> ack -> RUN(EventsA)) [] (goto?_: {x | goto.x <- EventsA} -> Pattern5A)
PiEmergencyA =  adaptE  -> ra!1 -> ack -> PiEmergencyA
RmA = let
			eventsR2A = union(EventsA,Monitors2A)
			eventsR4 = union(EventsA,Monitors4)
			eventsR5 = union(EventsA,Monitors5)


			R4 = normal((Pi4[|{|adapt,ack|}|] Pattern4) ) \ {|adapt,ack|}
			R2A = normal((Pi2A[|{|adapt,ack|}|] Pattern2A) ) \ {|adapt,ack|}
			R5 = normal((PiEmergencyA[|{|adaptE,ack|}|] Pattern5A) ) \ {|adaptE,ack|}
			
			FirstApproach = normal(( normal((R4[|inter(eventsR4,eventsR5)|] R5) )[|inter(EventsA,Union({eventsR4,eventsR5}))|] BehaviourA) )
			SecondApproach = normal(( normal((R2A[|inter(eventsR2A,eventsR5)|] R5) )[|inter(EventsA,Union({eventsR2A,eventsR5}))|] BehaviourA) )
		within normal((let R = ra?id -> (map(ra,id) /\ R) 
 within (A0/\ R)[|union( EventsA,{| ra|})|] (if(approachOne) then FirstApproach else SecondApproach))  \ {| ra|})

datatype Room = EA | EB | ED | Corr 

Processes = {0..1}
MaxAgents = 2
MaxAgentsEA = MaxAgents*2
MaxAgentsPair = MaxAgents
EmergencyCount = 2
approachOne = True

notR(rm) = {x | x<- Room, x != rm}
channel adapt : {0..MaxAgentsEA}
channel adaptE
channel emergency
channel goto : Room.Room

channel ack
 -- File /Users/aimee/IdeaProjects/ACSP Compiler/Examples/ArtGallery/ExhibitionArea/AssertionsF.acsp
RoomAB = let 
			monitorA = Union({Monitors4,Monitors5})
			monitorB = Union({Monitors5})
			monitorD = Union({Monitors2, Monitors5})
			eventsAB = Union({inter(EventsB, monitorA), inter(EventsA,monitorB),inter(EventsA,EventsB), inter(monitorA,monitorB)})
		within 
			normal( normal((RmA[|eventsAB|] RmB) ))

RoomBD = let 
			monitorB = Union({Monitors5})
			monitorD = Union({Monitors4, Monitors5})
			eventsBD = Union({inter(EventsB, monitorD), inter(EventsD,monitorB),inter(EventsD,EventsB), inter(monitorD,monitorB)})
		within 
			normal( normal((RmD[|eventsBD|] RmB) ))

ExhibitionArea = let 
					monitorA = Union({Monitors4,Monitors5})
					monitorB = Union({Monitors5})
					monitorD = Union({Monitors5, Monitors2})
					uEAD = union(EventsA,EventsB)
					uMAD = union(monitorA,monitorB)
					EventSet = Union({inter(uEAD, monitorD), inter(EventsD,uMAD),inter(uEAD,EventsD), inter(uMAD,monitorD)})
					AllRooms = normal( normal((RoomAB[|EventSet|] RmD) ))
				within 
					normal(AllRooms)
channel star
Requirement2 = let T(n) =   (n < MaxAgents & goto!EB!ED  -> T(n+1)) 
								[] (n > 0  & goto!ED!Corr -> T(n-1))
				within T(0)
Requirement4 = let T(n) =   (n < MaxAgentsEA & goto!Corr?_:notR(Corr)  -> T(n+1)) 
							[] (n >= 0  & goto?_:notR(Corr)!Corr -> T(n-1))
							[] (goto?_:notR(Corr)?_:notR(Corr) -> T(n))
			within T(0)
Movement = let M(a,b,d) = (a > 0 and b <= MaxAgentsEA & goto!EA!EB -> M(a-1,b+1,d)) 
							[] (b > 0 and a <= MaxAgentsEA & goto!EB!EA -> M(a+1,b-1,d))
							[] (b > 0 and d <= MaxAgentsEA & goto!EB!ED -> M(a,b-1,d+1)) 
							[] (d > 0 & goto!ED!Corr -> M(a,b,d-1)) 
							[] (a > 0 & goto!EA!Corr -> M(a-1,b,d)) 
							[] (a <= MaxAgentsEA & goto!Corr!EA -> M(a+1,b,d)) 
			within M(0,0,0)

Requirement5D = normal(((Requirement2 /\ emergency -> RUN(EventsD))[|EventsD|] BehaviourD) )
assert Requirement5D [F= normal((emergency -> SKIP[|{emergency}|] RmD) )

Requirement5B =  (BehaviourB /\ emergency -> RUN(EventsB))


assert ExhibitionArea :[deadlock free]
assert ExhibitionArea :[deterministic]
assert ExhibitionArea :[livelock free]

assert Movement [T= normal((ExhibitionArea[|{|emergency|}|] STOP) )
assert RmA :[deadlock free]
assert RmA :[deterministic]
assert RmA :[livelock free]
assert RmB :[deadlock free]
assert RmB :[deterministic]
assert RmB :[livelock free]

assert RmD :[deadlock free]
assert RmD :[deterministic]
assert RmD :[livelock free]

channel rb : {0..1}
channel rd : {0..1}
channel ra : {0..1}

map = \ chName,id @ if chName == rb and id == 0 then B1 
else if chName == rb and id == 1 then B0 
else if chName == rd and id == 0 then D1 
else if chName == rd and id == 1 then D0 
else if chName == ra and id == 0 then A1 
else if chName == ra and id == 1 then A0 
else SKIP
