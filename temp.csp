transparent normal 


datatype Room = EA | EB | ED | Corr

Processes = {0..1}
MaxAgents = 2
MaxAgentsEA = MaxAgents*2
MaxAgentsPair = MaxAgents


notR(rm) = {x | x<- Room, x != rm}
channel adapt : {0..MaxAgentsEA}
channel adaptE
channel emergency
channel goto : Room.Room

channel ack
EventsD = {goto.EB.ED,goto.ED.Corr}
Monitors2 = {emergency}
Monitors5 = {emergency}
D0 = (goto!ED!Corr -> D0) [] (goto!EB!ED -> D0)
D1 = goto!ED!Corr -> D1
BehaviourD = let D(n) =  (n > 0 & goto!ED!Corr -> D(n-1))
					[] (n <= MaxAgentsEA & goto!EB!ED -> D(n+1))
				within D(0)
Pattern2 = let P(n) =
			(n > 0 & goto!ED!Corr -> if n==MaxAgents then adapt!n-1 -> ack -> P(n-1) else P(n-1))
				[] (n <=MaxAgentsEA & goto!EB!ED -> if n == MaxAgents - 1 then adapt!n+1 -> ack -> P(n+1) else P(n+1))
				[] (emergency -> RUN(union(EventsD,Monitors2)))
		within P(0)
Pi2 =  adapt?v  ->  if v == MaxAgents then rd!0 -> ack -> Pi2 else rd!1 -> ack -> Pi2


Pattern5D = (emergency -> adaptE -> ack -> Pattern5D) [] (goto?_: {x | goto.x <- EventsD} -> Pattern5D)
Pi5D =  adaptE  -> rd!1 -> ack -> Pi5D
RmD = let
			eventsR2 = union(EventsD,Monitors2)
			eventsR5 = union(EventsD,Monitors5)

			events = union(eventsR2,eventsR5)
			R2 = (Pattern2 [|{|adapt,ack|}|] Pi2) \ {|adapt,ack|}
			R5 = (Pattern5D [|{|adaptE,ack|}|] Pi5D) \ {|adaptE,ack|}

			FirstApproach = R2 [|inter(eventsR2,eventsR5)|] R5

			AdptManager = BehaviourD [|inter(EventsD,events) |] R2
		within normal((let R = rd?id -> (map(rd,id) /\ R) 
 within (D0/\ R)[|union( EventsD,{| rd|})|] AdptManager) \ {| rd|})

assert RmD :[deadlock free]
assert RmD :[deterministic]
assert RmD :[livelock free]
assert Requirement2 [T= RmD [|{|emergency|}|] STOP
Requirement2 = let T(n) =   (n < MaxAgents & goto?_:notR(ED)!ED  -> T(n+1))
								[] (n > 0  & goto!ED?_:notR(ED) -> T(n-1))
								[] (goto?_:notR(ED)?_:notR(ED) -> T(n))
				within T(0)

channel rd : {0..1}

map = \ chName,id @ if chName == rd and id == 0 then D1 
else if chName == rd and id == 1 then D0 
else SKIP
