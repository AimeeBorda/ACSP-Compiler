
datatype Room = EA | EB | ED | Corr

Processes = {0..1}
MaxAgents = 2
MaxAgentsEA = MaxAgents*2
MaxAgentsPair = MaxAgents


notR(rm) = {x | x<- Room, x != rm}

---------------------------------------------
--		Events
---------------------------------------------
channel adapt : {0..MaxAgentsEA}
channel adaptE
channel emergency 				-- local state (True over MaxAgents, False under MaxAgents)
channel goto : Room.Room			-- agents' movement

channel ack

---------------------------------------------
--		Event for EB
---------------------------------------------
EventsD = {goto.EB.ED,goto.ED.Corr}
Monitors2 = {emergency}
Monitors5 = {emergency}

---------------------------------------------
--		Processes for ED
---------------------------------------------
D0 = (goto!ED!Corr -> D0) [] (goto!EB!ED -> D0)
D1 = goto!ED!Corr -> D1

---------------------------------------------
--		Behaviour for ED
---------------------------------------------
BehaviourD = let D(n) =  (n > 0 & goto!ED!Corr -> D(n-1))
					[] (n <= MaxAgentsEA & goto!EB!ED -> D(n+1))
				within D(0)

---------------------------------------------
--		Requirements for ED
---------------------------------------------
Pattern2 = let P(n) =
			(n > 0 & goto!ED!Corr -> if n==MaxAgents then adapt!n-1 -> ack -> P(n-1) else P(n-1))
				[] (n <=MaxAgentsEA & goto!EB!ED -> if n == MaxAgents - 1 then adapt!n+1 -> ack -> P(n+1) else P(n+1))
				[] (emergency -> RUN(union(EventsD,Monitors2)))
		within P(0)
Pi2 =  adapt?v  ->  if v == MaxAgents then rd!<D1>.ack -> Pi2 else rd!<D0>.ack -> Pi2


Pattern5D = (emergency -> adaptE -> ack -> Pattern5D) [] (goto?_: {x | goto.x <- EventsD} -> Pattern5D)
Pi5D =  adaptE  ->  rd!<D0>.ack -> Pi5D


---------------------------------------------
--		Composition
---------------------------------------------
RmD = let
			eventsR2 = union(EventsD,Monitors2)
			eventsR5 = union(EventsD,Monitors5)

			events = union(eventsR2,eventsR5)
			R2 = (Pattern2 [|{|adapt,ack|}|] Pi2) \ {|adapt,ack|}
			R5 = (Pattern5D [|{|adaptE,ack|}|] Pi5D) \ {|adaptE,ack|}

			FirstApproach = R2 [|inter(eventsR2,eventsR5)|] R5

			AdptManager = BehaviourD [|inter(EventsD,events) |] R2
		within
			(new rd)(rd[D0] [| EventsD |] AdptManager)

---------------------------------------------
--	 Assertions for Room D
---------------------------------------------

assert RmD :[deadlock free]
assert RmD :[deterministic]
assert RmD :[livelock free]

---------------------------------------------
--	 Assertions only applicable for First Approach
---------------------------------------------
assert Requirement2 [T= RmD [|{|emergency|}|] STOP

---------- at most MaxAgents people in room D ----------
Requirement2 = let T(n) =   (n < MaxAgents & goto?_:notR(ED)!ED  -> T(n+1))
								[] (n > 0  & goto!ED?_:notR(ED) -> T(n-1))
								[] (goto?_:notR(ED)?_:notR(ED) -> T(n))
				within T(0)