transparent normal

---------------------------------------------
--		Event for EB
---------------------------------------------
EventsD = {goto.EB.ED,goto.ED.Corr}
Monitors2 = {|emergency|}

---------------------------------------------
--		Processes for ED
---------------------------------------------
D0 = (goto!ED!Corr -> D0) [] (goto!EB!ED -> D0)
D1 = goto!ED!Corr -> D1

---------------------------------------------
--		Behaviour for ED
---------------------------------------------
BehaviourD = let D(n) =  (n > 0 & goto!ED!Corr -> D(n-1))
					[] (n <= MaxAgentsEA & goto!EB!ED -> D(n+1))
				within D(0)

---------------------------------------------
--		Requirements for ED
---------------------------------------------
Pattern2 = let P(n) = (n > 0 & goto!ED!Corr -> if n == MaxAgents then adapt!n-1 -> ack -> P(n-1) else P(n-1))
				[] (n <=MaxAgentsEA & goto!EB!ED -> if n == MaxAgents - 1 then adapt!n+1 -> ack -> P(n+1) else P(n+1))
				[] (emergency -> RUN(union(EventsD,Monitors2)))
		within P(0)
Pi2 =  adapt?v  ->  if v == MaxAgents then rd!<D1>.ack -> Pi2 else rd!<D0>.ack -> Pi2


Pattern5D = (emergency -> adaptE -> ack -> Pattern5D) [] (goto?_: {x | goto.x <- EventsD} -> Pattern5D)
Pi5D =  adaptE  ->  rd!<D0>.ack -> Pi5D


include "RmD.acsp"
---------------------------------------------
--		Composition
---------------------------------------------
RmB = let
			eventsR2B = union(EventsB,Monitors2B)
			eventsR5 = union(EventsB,Monitors5)

			events = Union({eventsR2B,eventsR5})
			R5 = (PiEmergencyB [|{|adaptE,ack|}|] PatternEmergencyB)  \ {|adaptE,ack|}
			R2B = (Pi2B [|{|adapt,ack|}|] Pattern2B) \ {|adapt,ack|}

			FirstApproach = R5
			SecondApproach = R5 [| inter(eventsR5,eventsR2B) |] R2B

			AdptManager = BehaviourB [|inter(EventsB, events) |] SecondApproach
			proc = (new rb)(rb[B0] [| EventsB |] AdptManager)
		within
			normal(proc)

EventsA = {goto.EB.EA,goto.EA.Corr,goto.EA.EB,goto.Corr.EA}

Monitors4 = {goto.ED.Corr,emergency}
Monitors2A = {goto.EB.ED,emergency}
Monitors5 = {emergency}

---------------------------------------------
--		Processes for EA
---------------------------------------------
A0 = (goto!EB!EA -> A0) [] (goto!EA?_:{Corr,EB} -> A0) [] (goto!Corr!EA -> A0)
A1 = (goto!EB!EA -> A1) [] (goto!EA?_:{Corr,EB} -> A1)

---------------------------------------------
--		Behaviour for EA
---------------------------------------------
BehaviourA =  let B(n) = (n <= MaxAgentsEA & goto!Corr!EA -> B(n+1))
							[] (n > 0 & goto!EA!Corr -> B(n-1))
							[] (n > 0 & goto!EA!EB -> B(n-1))
							[] (n <= MaxAgentsEA & goto!EB!EA -> B(n+1))
				within B(0)

---------------------------------------------
--		Requirements for EA
---------------------------------------------
Pattern4 =
		let P(n) =  (n > 0 & goto?_:{EA,ED}!Corr -> if n == MaxAgentsEA then adapt!n-1 -> ack-> P(n-1) else P(n-1))
				[] (n <= MaxAgentsEA & goto!Corr!EA -> if n == MaxAgentsEA - 1 then adapt!n+1 -> ack -> P(n+1) else P(n+1))
				[] (goto!EA!EB -> P(n))
				[] (goto!EB!EA -> P(n))
				[] (emergency -> RUN(union(EventsA,Monitors4)))

		within P(0)
Pi4 =  adapt?v  ->  if v >= MaxAgentsEA then ra!<A1>.ack -> Pi4 else ra!<A0>.ack -> Pi4

Pattern2A = let P(n) =  (n <= MaxAgentsPair & goto!Corr!EA -> if n == MaxAgentsPair - 1 then adapt!n+1 -> ack -> P(n+1) else P(n+1))
					[] (n > 0 & goto!EA!Corr -> if n == MaxAgentsPair then adapt!n-1 -> ack -> P(n-1) else P(n-1))
					[] (n > 0 & goto!EB!ED   -> if n == MaxAgentsPair then adapt!n-1 -> ack -> P(n-1) else P(n-1))
					[] (goto!EA!EB -> P(n))
					[] (goto!EB!EA -> P(n))
					[] (emergency -> RUN(union(EventsA,Monitors2A)))
			within P(0)
Pi2A =  adapt?v  ->  if v >= MaxAgentsPair then ra!<A1>.ack -> Pi2A else ra!<A0>.ack -> Pi2A

PatternEmergencyA = emergency -> adaptE -> ack -> PatternEmergencyA [] (goto?_: {x | goto.x <- EventsA} -> PatternEmergencyA)
PiEmergencyA =  adaptE  ->  ra!<A1>.ack -> PiEmergencyA

---------------------------------------------
--		Composition
---------------------------------------------
RmA = let
			eventsR2A = union(EventsA,Monitors2A)
			eventsR4 = union(EventsA,Monitors4)
			eventsR5 = union(EventsA,Monitors5)

			events = Union({eventsR2A,eventsR5})

			R4 = (Pi4 [|{|adapt,ack|}|] Pattern4) \ {|adapt,ack|}
			R2A = (Pi2A [|{|adapt,ack|}|] Pattern2A) \ {|adapt,ack|}
			R5 = (PiEmergencyA [|{|adaptE,ack|}|] PatternEmergencyA) \ {|adaptE,ack|}

			FirstApproach = R4 [|inter(eventsR4,eventsR5) |] R5
			SecondApproach =  (R2A [|inter(eventsR2A,eventsR4) |] R4) [|inter(union(eventsR4,eventsR2A),eventsR5)|] R5

			AdptManager = BehaviourA [|inter(EventsA,events)|] SecondApproach
			proc = (new ra)(ra[A0] [| EventsA |] AdptManager)
		within
			normal(proc)

datatype Room = EA | EB | ED | Corr

Processes = {0..1}
MaxAgents = 2
MaxAgentsEA = MaxAgents*2
MaxAgentsPair = MaxAgents
EmergencyCount = 2


---------------------------------------------
--		Events
---------------------------------------------
channel adapt : {0..MaxAgentsEA}
channel adaptE
channel emergency 				-- local state (True over MaxAgents, False under MaxAgents)
channel goto : Room.Room			-- agents' movement

channel ack

---------------------------------------------
--		Composition
---------------------------------------------
RoomAB = let
			monitorA = Union({Monitors2A,Monitors5})
			monitorB = Union({Monitors2B,Monitors5})
			monitorD = Union({Monitors5})
			eventsAB = Union({inter(EventsB, monitorA), inter(EventsA,monitorB),inter(EventsA,EventsB), inter(monitorA,monitorB)})
		within
			normal(RmA [| eventsAB |] RmB)

RoomBD = let
			monitorB = Union({Monitors2B,Monitors5})
			monitorD = Union({Monitors5})
			eventsBD = Union({inter(EventsB, monitorD), inter(EventsD,monitorB),inter(EventsD,EventsB), inter(monitorD,monitorB)})
		within
			normal(RmD [| eventsBD |] RmB)

ExhibitionArea = let
					monitorA = Union({Monitors2A,Monitors5})
					monitorB = Union({Monitors2B,Monitors5})
					monitorD = Union({Monitors5})
					uEAD = union(EventsA,EventsB)
					uMAD = union(monitorA,monitorB)
					EventSet = Union({inter(uEAD, monitorD), inter(EventsD,uMAD),inter(uEAD,EventsD), inter(uMAD,monitorD)})
					AllRooms = normal(RoomAB [|EventSet|] RmD)
				within
					normal(AllRooms)



---------------------------------------------
--		Assertions
---------------------------------------------

---------------------------------------------
--		Requirements Assertions
---------------------------------------------
channel star

---------- at most MaxAgents people in room D ----------
Requirement2 = let T(n) =   (n < MaxAgents & goto?_:notR(ED)!ED  -> T(n+1))
								[] (n > 0  & goto!ED?_:notR(ED) -> T(n-1))
								[] (goto?_:notR(ED)?_:notR(ED) -> T(n))
				within T(0)

---------- at most MaxAgentsEA people in the Exhibition Area ----------


Requirement4 = let T(n) =   (n < MaxAgentsEA & goto!Corr?_:notR(Corr)  -> T(n+1))
							[] (n >= 0  & goto?_:notR(Corr)!Corr -> T(n-1))
							[] (goto?_:notR(Corr)?_:notR(Corr) -> T(n))
			within T(0)

---------- Logical Movement through Exhibition Area ----------
Movement = let M(a,b,d) = (a > 0 and b <= MaxAgentsEA & goto!EA!EB -> M(a-1,b+1,d))
							[] (b > 0 and a <= MaxAgentsEA & goto!EB!EA -> M(a+1,b-1,d))
							[] (b > 0 and d <= MaxAgentsEA & goto!EB!ED -> M(a,b-1,d+1))
							[] (d > 0 & goto!ED!Corr -> M(a,b,d-1))
							[] (a > 0 & goto!EA!Corr -> M(a-1,b,d))
							[] (a <= MaxAgentsEA & goto!Corr!EA -> M(a+1,b,d))
			within M(0,0,0)


---------- approach two of pair-wise count ----------

ExtraRequirement = RoomABMovement [|{goto.EA.EB,goto.EB.EA,goto.EB.ED}|] RoomBDMovement


RoomABMovement = let P(a,b) =  (a > 0  & goto!EA!EB -> P(a-1,b+1))
								[] (b > 0  & goto!EB!EA -> P(a+1,b-1))
								[] (b > 0 & goto!EB!ED -> P(a,b-1))
								[] (a > 0  & goto!EA!Corr -> P(a-1,b))
								[] (a + b < MaxAgentsPair & goto!Corr!EA -> P(a+1,b))
			within P(0,0)

RoomBDMovement = let P(b,d) =  (d + b < MaxAgentsPair & goto!EA!EB -> P(b+1,d))
								[] (b > 0  & goto!EB!EA -> P(b-1,d))
								[] (b > 0  & goto!EB!ED -> P(b-1,d+1))
								[] (d > 0  & goto!ED!Corr -> P(b,d-1))
				within P(0,0)

notR(rm) = {x | x<- Room, x != rm}

---------------------------------------------
--	 Assertions for EA
---------------------------------------------

assert ExhibitionArea :[deadlock free]
assert ExhibitionArea :[deterministic]
assert ExhibitionArea :[livelock free]

assert Movement [T= ExhibitionArea [|{|emergency|}|] STOP


assert Requirement2 [T= ExhibitionArea [|{|emergency|}|] STOP
assert Requirement4 [T= ExhibitionArea [|{|emergency|}|] STOP


---------------------------------------------
--		Room A Assertions
---------------------------------------------
assert RmA :[deadlock free]
assert RmA :[deterministic]
assert RmA :[livelock free]

---------------------------------------------
--	 Assertions for Room B
---------------------------------------------
assert RmB :[deadlock free]
assert RmB :[deterministic]
assert RmB :[livelock free]

---------------------------------------------
--	 Assertions for Room D
---------------------------------------------

assert RmD :[deadlock free]
assert RmD :[deterministic]
assert RmD :[livelock free]


---------------------------------------------
--	 Assertions only applicable for First Approach
---------------------------------------------
assert Requirement2 [T= RmD [|{|emergency|}|] STOP

---------------------------------------------
--	 Assertions only applicable for Second Approach
---------------------------------------------
assert Requirement4 [T= RoomAB [|{|emergency|}|] STOP

assert RoomBDMovement[T= RoomBD[|{|emergency|}|] STOP 			-- for Second Approach only
assert Requirement2 [T= RoomBD [|{|emergency|}|] STOP
assert ExtraRequirement [T= ExhibitionArea [|{|emergency|}|] STOP
