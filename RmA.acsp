EventsA = {goto.EB.EA,goto.EA.Corr,goto.EA.EB,goto.Corr.EA}

Monitors4 = {goto.ED.Corr,emergency}
Monitors2A = {goto.EB.ED,emergency}
Monitors5 = {emergency}

---------------------------------------------
--		Processes for EA
---------------------------------------------
A0 = (goto!EB!EA -> A0) [] (goto!EA?_:{Corr,EB} -> A0) [] (goto!Corr!EA -> A0)
A1 = (goto!EB!EA -> A1) [] (goto!EA?_:{Corr,EB} -> A1)

---------------------------------------------
--		Behaviour for EA
---------------------------------------------
BehaviourA =  let B(n) = (n <= MaxAgentsEA & goto!Corr!EA -> B(n+1))
							[] (n > 0 & goto!EA!Corr -> B(n-1))
							[] (n > 0 & goto!EA!EB -> B(n-1))
							[] (n <= MaxAgentsEA & goto!EB!EA -> B(n+1))
				within B(0)

---------------------------------------------
--		Requirements for EA
---------------------------------------------	
Pattern4 =  
		let P(n) =  (n > 0 & goto?_:{EA,ED}!Corr -> if (n == MaxAgentsEA) then adapt!n-1 -> ack-> P(n-1) else P(n-1))
				[] (n <= MaxAgentsEA & goto!Corr!EA -> if (n == MaxAgentsEA - 1) then adapt!n+1 -> ack -> P(n+1) else P(n+1))
				[] (goto!EA!EB -> P(n))  
				[] (goto!EB!EA -> P(n)) 
				[] (emergency -> RUN(union(EventsA,Monitors4))) 
			
		within P(0)
Pi4 =  adapt?v  ->  if v >= MaxAgentsEA then ra!<A1>.ack -> Pi4 else ra!<A0>.ack -> Pi4

Pattern2A = let P(n) =  (n <= MaxAgentsPair & goto!Corr!EA -> if (n == MaxAgentsPair - 1) then adapt!n+1 -> ack -> P(n+1) else P(n+1))
					[] (n > 0 & goto!EA!Corr -> if (n == MaxAgentsPair) then adapt!n-1 -> ack -> P(n-1) else P(n-1))
					[] (n > 0 & goto!EB!ED   -> if (n == MaxAgentsPair) then adapt!n-1 -> ack -> P(n-1) else P(n-1))
					[] (goto!EA!EB -> P(n))  
					[] (goto!EB!EA -> P(n)) 
					[] (emergency -> RUN(union(EventsA,Monitors2A))) 
			within P(0)
Pi2A =  adapt?v  ->  if v >= MaxAgentsPair then ra!<A1>.ack -> Pi2A else ra!<A0>.ack -> Pi2A


Pattern5A = (emergency -> adaptE -> ack -> RUN(EventsA)) [] (goto?_: {x | goto.x <- EventsA} -> Pattern5A)
PiEmergencyA =  adaptE  ->  ra!<A0>.ack -> PiEmergencyA

---------------------------------------------
--		Composition
---------------------------------------------
RmA = let
			eventsR2A = union(EventsA,Monitors2A)
			eventsR4 = union(EventsA,Monitors4)
			eventsR5 = union(EventsA,Monitors5)


			R4 = (Pi4 [|{|adapt,ack|}|] Pattern4) \ {|adapt,ack|}
			R2A = (Pi2A [|{|adapt,ack|}|] Pattern2A) \ {|adapt,ack|}
			R5 = (PiEmergencyA [|{|adaptE,ack|}|] Pattern5A) \ {|adaptE,ack|}
			
			FirstApproach = ((R4 [|inter(eventsR4,eventsR5) |] R5)  [|inter(EventsA,Union({eventsR4,eventsR5}))|] BehaviourA)
			SecondApproach =  ((R2A [|inter(eventsR2A,eventsR5) |] R5) [|inter(EventsA,Union({eventsR2A,eventsR5}))|] BehaviourA)
		within
			(new ra)(ra[A0] [| EventsA |] (if(approachOne) then FirstApproach else SecondApproach))